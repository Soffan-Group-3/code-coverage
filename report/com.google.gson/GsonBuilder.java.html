<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="sv"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GsonBuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Gson</a> &gt; <a href="index.source.html" class="el_package">com.google.gson</a> &gt; <span class="el_source">GsonBuilder.java</span></div><h1>GsonBuilder.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2008 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.gson;

import static com.google.gson.Gson.DEFAULT_COMPLEX_MAP_KEYS;
import static com.google.gson.Gson.DEFAULT_DATE_PATTERN;
import static com.google.gson.Gson.DEFAULT_ESCAPE_HTML;
import static com.google.gson.Gson.DEFAULT_FORMATTING_STYLE;
import static com.google.gson.Gson.DEFAULT_JSON_NON_EXECUTABLE;
import static com.google.gson.Gson.DEFAULT_NUMBER_TO_NUMBER_STRATEGY;
import static com.google.gson.Gson.DEFAULT_OBJECT_TO_NUMBER_STRATEGY;
import static com.google.gson.Gson.DEFAULT_SERIALIZE_NULLS;
import static com.google.gson.Gson.DEFAULT_SPECIALIZE_FLOAT_VALUES;
import static com.google.gson.Gson.DEFAULT_STRICTNESS;
import static com.google.gson.Gson.DEFAULT_USE_JDK_UNSAFE;

import com.google.errorprone.annotations.CanIgnoreReturnValue;
import com.google.errorprone.annotations.InlineMe;
import com.google.gson.annotations.Since;
import com.google.gson.annotations.Until;
import com.google.gson.internal.$Gson$Preconditions;
import com.google.gson.internal.Excluder;
import com.google.gson.internal.bind.DefaultDateTypeAdapter;
import com.google.gson.internal.bind.TreeTypeAdapter;
import com.google.gson.internal.bind.TypeAdapters;
import com.google.gson.internal.sql.SqlTypesSupport;
import com.google.gson.reflect.TypeToken;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.lang.reflect.Type;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

/**
 * Use this builder to construct a {@link Gson} instance when you need to set configuration options
 * other than the default. For {@link Gson} with default configuration, it is simpler to use {@code
 * new Gson()}. {@code GsonBuilder} is best used by creating it, and then invoking its various
 * configuration methods, and finally calling create.
 *
 * &lt;p&gt;The following example shows how to use the {@code GsonBuilder} to construct a Gson instance:
 *
 * &lt;pre&gt;
 * Gson gson = new GsonBuilder()
 *     .registerTypeAdapter(Id.class, new IdTypeAdapter())
 *     .enableComplexMapKeySerialization()
 *     .serializeNulls()
 *     .setDateFormat(DateFormat.LONG, DateFormat.LONG)
 *     .setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE)
 *     .setPrettyPrinting()
 *     .setVersion(1.0)
 *     .create();
 * &lt;/pre&gt;
 *
 * &lt;p&gt;Notes:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;The order of invocation of configuration methods does not matter.
 *   &lt;li&gt;The default serialization of {@link Date} and its subclasses in Gson does not contain
 *       time-zone information. So, if you are using date/time instances, use {@code GsonBuilder}
 *       and its {@code setDateFormat} methods.
 *   &lt;li&gt;By default no explicit {@link Strictness} is set; some of the {@link Gson} methods behave
 *       as if {@link Strictness#LEGACY_STRICT} was used whereas others behave as if {@link
 *       Strictness#LENIENT} was used. Prefer explicitly setting a strictness with {@link
 *       #setStrictness(Strictness)} to avoid this legacy behavior.
 * &lt;/ul&gt;
 *
 * @author Inderjeet Singh
 * @author Joel Leitch
 * @author Jesse Wilson
 */
public final class GsonBuilder {
<span class="fc" id="L94">  private Excluder excluder = Excluder.DEFAULT;</span>
<span class="fc" id="L95">  private LongSerializationPolicy longSerializationPolicy = LongSerializationPolicy.DEFAULT;</span>
<span class="fc" id="L96">  private FieldNamingStrategy fieldNamingPolicy = FieldNamingPolicy.IDENTITY;</span>
<span class="fc" id="L97">  private final Map&lt;Type, InstanceCreator&lt;?&gt;&gt; instanceCreators = new HashMap&lt;&gt;();</span>
<span class="fc" id="L98">  private final List&lt;TypeAdapterFactory&gt; factories = new ArrayList&lt;&gt;();</span>

  /** tree-style hierarchy factories. These come after factories for backwards compatibility. */
<span class="fc" id="L101">  private final List&lt;TypeAdapterFactory&gt; hierarchyFactories = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L103">  private boolean serializeNulls = DEFAULT_SERIALIZE_NULLS;</span>
<span class="fc" id="L104">  private String datePattern = DEFAULT_DATE_PATTERN;</span>
<span class="fc" id="L105">  private int dateStyle = DateFormat.DEFAULT;</span>
<span class="fc" id="L106">  private int timeStyle = DateFormat.DEFAULT;</span>
<span class="fc" id="L107">  private boolean complexMapKeySerialization = DEFAULT_COMPLEX_MAP_KEYS;</span>
<span class="fc" id="L108">  private boolean serializeSpecialFloatingPointValues = DEFAULT_SPECIALIZE_FLOAT_VALUES;</span>
<span class="fc" id="L109">  private boolean escapeHtmlChars = DEFAULT_ESCAPE_HTML;</span>
<span class="fc" id="L110">  private FormattingStyle formattingStyle = DEFAULT_FORMATTING_STYLE;</span>
<span class="fc" id="L111">  private boolean generateNonExecutableJson = DEFAULT_JSON_NON_EXECUTABLE;</span>
<span class="fc" id="L112">  private Strictness strictness = DEFAULT_STRICTNESS;</span>
<span class="fc" id="L113">  private boolean useJdkUnsafe = DEFAULT_USE_JDK_UNSAFE;</span>
<span class="fc" id="L114">  private ToNumberStrategy objectToNumberStrategy = DEFAULT_OBJECT_TO_NUMBER_STRATEGY;</span>
<span class="fc" id="L115">  private ToNumberStrategy numberToNumberStrategy = DEFAULT_NUMBER_TO_NUMBER_STRATEGY;</span>
<span class="fc" id="L116">  private final ArrayDeque&lt;ReflectionAccessFilter&gt; reflectionFilters = new ArrayDeque&lt;&gt;();</span>

  /**
   * Creates a GsonBuilder instance that can be used to build Gson with various configuration
   * settings. GsonBuilder follows the builder pattern, and it is typically used by first invoking
   * various configuration methods to set desired options, and finally calling {@link #create()}.
   */
<span class="fc" id="L123">  public GsonBuilder() {}</span>

  /**
   * Constructs a GsonBuilder instance from a Gson instance. The newly constructed GsonBuilder has
   * the same configuration as the previously built Gson instance.
   *
   * @param gson the gson instance whose configuration should be applied to a new GsonBuilder.
   */
<span class="fc" id="L131">  GsonBuilder(Gson gson) {</span>
<span class="fc" id="L132">    this.excluder = gson.excluder;</span>
<span class="fc" id="L133">    this.fieldNamingPolicy = gson.fieldNamingStrategy;</span>
<span class="fc" id="L134">    this.instanceCreators.putAll(gson.instanceCreators);</span>
<span class="fc" id="L135">    this.serializeNulls = gson.serializeNulls;</span>
<span class="fc" id="L136">    this.complexMapKeySerialization = gson.complexMapKeySerialization;</span>
<span class="fc" id="L137">    this.generateNonExecutableJson = gson.generateNonExecutableJson;</span>
<span class="fc" id="L138">    this.escapeHtmlChars = gson.htmlSafe;</span>
<span class="fc" id="L139">    this.formattingStyle = gson.formattingStyle;</span>
<span class="fc" id="L140">    this.strictness = gson.strictness;</span>
<span class="fc" id="L141">    this.serializeSpecialFloatingPointValues = gson.serializeSpecialFloatingPointValues;</span>
<span class="fc" id="L142">    this.longSerializationPolicy = gson.longSerializationPolicy;</span>
<span class="fc" id="L143">    this.datePattern = gson.datePattern;</span>
<span class="fc" id="L144">    this.dateStyle = gson.dateStyle;</span>
<span class="fc" id="L145">    this.timeStyle = gson.timeStyle;</span>
<span class="fc" id="L146">    this.factories.addAll(gson.builderFactories);</span>
<span class="fc" id="L147">    this.hierarchyFactories.addAll(gson.builderHierarchyFactories);</span>
<span class="fc" id="L148">    this.useJdkUnsafe = gson.useJdkUnsafe;</span>
<span class="fc" id="L149">    this.objectToNumberStrategy = gson.objectToNumberStrategy;</span>
<span class="fc" id="L150">    this.numberToNumberStrategy = gson.numberToNumberStrategy;</span>
<span class="fc" id="L151">    this.reflectionFilters.addAll(gson.reflectionFilters);</span>
<span class="fc" id="L152">  }</span>

  /**
   * Configures Gson to enable versioning support. Versioning support works based on the annotation
   * types {@link Since} and {@link Until}. It allows including or excluding fields and classes
   * based on the specified version. See the documentation of these annotation types for more
   * information.
   *
   * &lt;p&gt;By default versioning support is disabled and usage of {@code @Since} and {@code @Until} has
   * no effect.
   *
   * @param version the version number to use.
   * @return a reference to this {@code GsonBuilder} object to fulfill the &quot;Builder&quot; pattern
   * @throws IllegalArgumentException if the version number is NaN or negative
   * @see Since
   * @see Until
   */
  @CanIgnoreReturnValue
  public GsonBuilder setVersion(double version) {
<span class="fc bfc" id="L171" title="All 4 branches covered.">    if (Double.isNaN(version) || version &lt; 0.0) {</span>
<span class="fc" id="L172">      throw new IllegalArgumentException(&quot;Invalid version: &quot; + version);</span>
    }
<span class="fc" id="L174">    excluder = excluder.withVersion(version);</span>
<span class="fc" id="L175">    return this;</span>
  }

  /**
   * Configures Gson to excludes all class fields that have the specified modifiers. By default,
   * Gson will exclude all fields marked {@code transient} or {@code static}. This method will
   * override that behavior.
   *
   * &lt;p&gt;This is a convenience method which behaves as if an {@link ExclusionStrategy} which excludes
   * these fields was {@linkplain #setExclusionStrategies(ExclusionStrategy...) registered with this
   * builder}.
   *
   * @param modifiers the field modifiers. You must use the modifiers specified in the {@link
   *     java.lang.reflect.Modifier} class. For example, {@link
   *     java.lang.reflect.Modifier#TRANSIENT}, {@link java.lang.reflect.Modifier#STATIC}.
   * @return a reference to this {@code GsonBuilder} object to fulfill the &quot;Builder&quot; pattern
   */
  @CanIgnoreReturnValue
  public GsonBuilder excludeFieldsWithModifiers(int... modifiers) {
<span class="fc" id="L194">    Objects.requireNonNull(modifiers);</span>
<span class="fc" id="L195">    excluder = excluder.withModifiers(modifiers);</span>
<span class="fc" id="L196">    return this;</span>
  }

  /**
   * Makes the output JSON non-executable in Javascript by prefixing the generated JSON with some
   * special text. This prevents attacks from third-party sites through script sourcing. See &lt;a
   * href=&quot;http://code.google.com/p/google-gson/issues/detail?id=42&quot;&gt;Gson Issue 42&lt;/a&gt; for details.
   *
   * @return a reference to this {@code GsonBuilder} object to fulfill the &quot;Builder&quot; pattern
   * @since 1.3
   */
  @CanIgnoreReturnValue
  public GsonBuilder generateNonExecutableJson() {
<span class="fc" id="L209">    this.generateNonExecutableJson = true;</span>
<span class="fc" id="L210">    return this;</span>
  }

  /**
   * Configures Gson to exclude all fields from consideration for serialization and deserialization
   * that do not have the {@link com.google.gson.annotations.Expose} annotation.
   *
   * &lt;p&gt;This is a convenience method which behaves as if an {@link ExclusionStrategy} which excludes
   * these fields was {@linkplain #setExclusionStrategies(ExclusionStrategy...) registered with this
   * builder}.
   *
   * @return a reference to this {@code GsonBuilder} object to fulfill the &quot;Builder&quot; pattern
   */
  @CanIgnoreReturnValue
  public GsonBuilder excludeFieldsWithoutExposeAnnotation() {
<span class="fc" id="L225">    excluder = excluder.excludeFieldsWithoutExposeAnnotation();</span>
<span class="fc" id="L226">    return this;</span>
  }

  /**
   * Configures Gson to serialize null fields. By default, Gson omits all fields that are null
   * during serialization.
   *
   * @return a reference to this {@code GsonBuilder} object to fulfill the &quot;Builder&quot; pattern
   * @since 1.2
   */
  @CanIgnoreReturnValue
  public GsonBuilder serializeNulls() {
<span class="fc" id="L238">    this.serializeNulls = true;</span>
<span class="fc" id="L239">    return this;</span>
  }

  /**
   * Configures Gson to serialize {@code Map} objects with complex keys as JSON arrays. Enabling
   * this feature will only change the serialized form if the map key is a complex type (i.e.
   * non-primitive) in its &lt;strong&gt;serialized&lt;/strong&gt; JSON form. The default implementation of map
   * serialization uses {@code toString()} on the key; however, when this is called then one of the
   * following cases apply:
   *
   * &lt;p&gt;&lt;b&gt;Maps as JSON objects&lt;/b&gt;
   *
   * &lt;p&gt;For this case, assume that a type adapter is registered to serialize and deserialize some
   * {@code Point} class, which contains an x and y coordinate, to/from the JSON Primitive string
   * value {@code &quot;(x,y)&quot;}. The Java map would then be serialized as a {@link JsonObject}.
   *
   * &lt;p&gt;Below is an example:
   *
   * &lt;pre&gt;{@code
   * Gson gson = new GsonBuilder()
   *     .register(Point.class, new MyPointTypeAdapter())
   *     .enableComplexMapKeySerialization()
   *     .create();
   *
   * Map&lt;Point, String&gt; original = new LinkedHashMap&lt;&gt;();
   * original.put(new Point(5, 6), &quot;a&quot;);
   * original.put(new Point(8, 8), &quot;b&quot;);
   * System.out.println(gson.toJson(original, type));
   * }&lt;/pre&gt;
   *
   * The above code prints this JSON object:
   *
   * &lt;pre&gt;{@code
   * {
   *   &quot;(5,6)&quot;: &quot;a&quot;,
   *   &quot;(8,8)&quot;: &quot;b&quot;
   * }
   * }&lt;/pre&gt;
   *
   * &lt;p&gt;&lt;b&gt;Maps as JSON arrays&lt;/b&gt;
   *
   * &lt;p&gt;For this case, assume that a type adapter was NOT registered for some {@code Point} class,
   * but rather the default Gson serialization is applied. In this case, some {@code new Point(2,3)}
   * would serialize as {@code {&quot;x&quot;:2,&quot;y&quot;:3}}.
   *
   * &lt;p&gt;Given the assumption above, a {@code Map&lt;Point, String&gt;} will be serialized as an array of
   * arrays (can be viewed as an entry set of pairs).
   *
   * &lt;p&gt;Below is an example of serializing complex types as JSON arrays:
   *
   * &lt;pre&gt;{@code
   * Gson gson = new GsonBuilder()
   *     .enableComplexMapKeySerialization()
   *     .create();
   *
   * Map&lt;Point, String&gt; original = new LinkedHashMap&lt;&gt;();
   * original.put(new Point(5, 6), &quot;a&quot;);
   * original.put(new Point(8, 8), &quot;b&quot;);
   * System.out.println(gson.toJson(original, type));
   * }&lt;/pre&gt;
   *
   * The JSON output would look as follows:
   *
   * &lt;pre&gt;{@code
   * [
   *   [
   *     {
   *       &quot;x&quot;: 5,
   *       &quot;y&quot;: 6
   *     },
   *     &quot;a&quot;
   *   ],
   *   [
   *     {
   *       &quot;x&quot;: 8,
   *       &quot;y&quot;: 8
   *     },
   *     &quot;b&quot;
   *   ]
   * ]
   * }&lt;/pre&gt;
   *
   * @return a reference to this {@code GsonBuilder} object to fulfill the &quot;Builder&quot; pattern
   * @since 1.7
   */
  @CanIgnoreReturnValue
  public GsonBuilder enableComplexMapKeySerialization() {
<span class="fc" id="L326">    complexMapKeySerialization = true;</span>
<span class="fc" id="L327">    return this;</span>
  }

  /**
   * Configures Gson to exclude inner classes (= non-{@code static} nested classes) during
   * serialization and deserialization. This is a convenience method which behaves as if an {@link
   * ExclusionStrategy} which excludes inner classes was {@linkplain
   * #setExclusionStrategies(ExclusionStrategy...) registered with this builder}. This means inner
   * classes will be serialized as JSON {@code null}, and will be deserialized as Java {@code null}
   * with their JSON data being ignored. And fields with an inner class as type will be ignored
   * during serialization and deserialization.
   *
   * &lt;p&gt;By default Gson serializes and deserializes inner classes, but ignores references to the
   * enclosing instance. Deserialization might not be possible at all when {@link
   * #disableJdkUnsafe()} is used (and no custom {@link InstanceCreator} is registered), or it can
   * lead to unexpected {@code NullPointerException}s when the deserialized instance is used
   * afterwards.
   *
   * &lt;p&gt;In general using inner classes with Gson should be avoided; they should be converted to
   * {@code static} nested classes if possible.
   *
   * @return a reference to this {@code GsonBuilder} object to fulfill the &quot;Builder&quot; pattern
   * @since 1.3
   */
  @CanIgnoreReturnValue
  public GsonBuilder disableInnerClassSerialization() {
<span class="fc" id="L353">    excluder = excluder.disableInnerClassSerialization();</span>
<span class="fc" id="L354">    return this;</span>
  }

  /**
   * Configures Gson to apply a specific serialization policy for {@code Long} and {@code long}
   * objects.
   *
   * @param serializationPolicy the particular policy to use for serializing longs.
   * @return a reference to this {@code GsonBuilder} object to fulfill the &quot;Builder&quot; pattern
   * @since 1.3
   */
  @CanIgnoreReturnValue
  public GsonBuilder setLongSerializationPolicy(LongSerializationPolicy serializationPolicy) {
<span class="fc" id="L367">    this.longSerializationPolicy = Objects.requireNonNull(serializationPolicy);</span>
<span class="fc" id="L368">    return this;</span>
  }

  /**
   * Configures Gson to apply a specific naming policy to an object's fields during serialization
   * and deserialization.
   *
   * &lt;p&gt;This method just delegates to {@link #setFieldNamingStrategy(FieldNamingStrategy)}.
   */
  @CanIgnoreReturnValue
  public GsonBuilder setFieldNamingPolicy(FieldNamingPolicy namingConvention) {
<span class="fc" id="L379">    return setFieldNamingStrategy(namingConvention);</span>
  }

  /**
   * Configures Gson to apply a specific naming strategy to an object's fields during serialization
   * and deserialization.
   *
   * &lt;p&gt;The created Gson instance might only use the field naming strategy once for a field and
   * cache the result. It is not guaranteed that the strategy will be used again every time the
   * value of a field is serialized or deserialized.
   *
   * @param fieldNamingStrategy the naming strategy to apply to the fields
   * @return a reference to this {@code GsonBuilder} object to fulfill the &quot;Builder&quot; pattern
   * @since 1.3
   */
  @CanIgnoreReturnValue
  public GsonBuilder setFieldNamingStrategy(FieldNamingStrategy fieldNamingStrategy) {
<span class="fc" id="L396">    this.fieldNamingPolicy = Objects.requireNonNull(fieldNamingStrategy);</span>
<span class="fc" id="L397">    return this;</span>
  }

  /**
   * Configures Gson to apply a specific number strategy during deserialization of {@link Object}.
   *
   * @param objectToNumberStrategy the actual object-to-number strategy
   * @return a reference to this {@code GsonBuilder} object to fulfill the &quot;Builder&quot; pattern
   * @see ToNumberPolicy#DOUBLE The default object-to-number strategy
   * @since 2.8.9
   */
  @CanIgnoreReturnValue
  public GsonBuilder setObjectToNumberStrategy(ToNumberStrategy objectToNumberStrategy) {
<span class="fc" id="L410">    this.objectToNumberStrategy = Objects.requireNonNull(objectToNumberStrategy);</span>
<span class="fc" id="L411">    return this;</span>
  }

  /**
   * Configures Gson to apply a specific number strategy during deserialization of {@link Number}.
   *
   * @param numberToNumberStrategy the actual number-to-number strategy
   * @return a reference to this {@code GsonBuilder} object to fulfill the &quot;Builder&quot; pattern
   * @see ToNumberPolicy#LAZILY_PARSED_NUMBER The default number-to-number strategy
   * @since 2.8.9
   */
  @CanIgnoreReturnValue
  public GsonBuilder setNumberToNumberStrategy(ToNumberStrategy numberToNumberStrategy) {
<span class="fc" id="L424">    this.numberToNumberStrategy = Objects.requireNonNull(numberToNumberStrategy);</span>
<span class="fc" id="L425">    return this;</span>
  }

  /**
   * Configures Gson to apply a set of exclusion strategies during both serialization and
   * deserialization. Each of the {@code strategies} will be applied as a disjunction rule. This
   * means that if one of the {@code strategies} suggests that a field (or class) should be skipped
   * then that field (or object) is skipped during serialization/deserialization. The strategies are
   * added to the existing strategies (if any); the existing strategies are not replaced.
   *
   * &lt;p&gt;Fields are excluded for serialization and deserialization when {@link
   * ExclusionStrategy#shouldSkipField(FieldAttributes) shouldSkipField} returns {@code true}, or
   * when {@link ExclusionStrategy#shouldSkipClass(Class) shouldSkipClass} returns {@code true} for
   * the field type. Gson behaves as if the field did not exist; its value is not serialized and on
   * deserialization if a JSON member with this name exists it is skipped by default.&lt;br&gt;
   * When objects of an excluded type (as determined by {@link
   * ExclusionStrategy#shouldSkipClass(Class) shouldSkipClass}) are serialized a JSON null is
   * written to output, and when deserialized the JSON value is skipped and {@code null} is
   * returned.
   *
   * &lt;p&gt;The created Gson instance might only use an exclusion strategy once for a field or class and
   * cache the result. It is not guaranteed that the strategy will be used again every time the
   * value of a field or a class is serialized or deserialized.
   *
   * @param strategies the set of strategy object to apply during object (de)serialization.
   * @return a reference to this {@code GsonBuilder} object to fulfill the &quot;Builder&quot; pattern
   * @since 1.4
   */
  @CanIgnoreReturnValue
  public GsonBuilder setExclusionStrategies(ExclusionStrategy... strategies) {
<span class="fc" id="L455">    Objects.requireNonNull(strategies);</span>
<span class="fc bfc" id="L456" title="All 2 branches covered.">    for (ExclusionStrategy strategy : strategies) {</span>
<span class="fc" id="L457">      excluder = excluder.withExclusionStrategy(strategy, true, true);</span>
    }
<span class="fc" id="L459">    return this;</span>
  }

  /**
   * Configures Gson to apply the passed in exclusion strategy during serialization. If this method
   * is invoked numerous times with different exclusion strategy objects then the exclusion
   * strategies that were added will be applied as a disjunction rule. This means that if one of the
   * added exclusion strategies suggests that a field (or class) should be skipped then that field
   * (or object) is skipped during its serialization.
   *
   * &lt;p&gt;See the documentation of {@link #setExclusionStrategies(ExclusionStrategy...)} for a
   * detailed description of the effect of exclusion strategies.
   *
   * @param strategy an exclusion strategy to apply during serialization.
   * @return a reference to this {@code GsonBuilder} object to fulfill the &quot;Builder&quot; pattern
   * @since 1.7
   */
  @CanIgnoreReturnValue
  public GsonBuilder addSerializationExclusionStrategy(ExclusionStrategy strategy) {
<span class="fc" id="L478">    Objects.requireNonNull(strategy);</span>
<span class="fc" id="L479">    excluder = excluder.withExclusionStrategy(strategy, true, false);</span>
<span class="fc" id="L480">    return this;</span>
  }

  /**
   * Configures Gson to apply the passed in exclusion strategy during deserialization. If this
   * method is invoked numerous times with different exclusion strategy objects then the exclusion
   * strategies that were added will be applied as a disjunction rule. This means that if one of the
   * added exclusion strategies suggests that a field (or class) should be skipped then that field
   * (or object) is skipped during its deserialization.
   *
   * &lt;p&gt;See the documentation of {@link #setExclusionStrategies(ExclusionStrategy...)} for a
   * detailed description of the effect of exclusion strategies.
   *
   * @param strategy an exclusion strategy to apply during deserialization.
   * @return a reference to this {@code GsonBuilder} object to fulfill the &quot;Builder&quot; pattern
   * @since 1.7
   */
  @CanIgnoreReturnValue
  public GsonBuilder addDeserializationExclusionStrategy(ExclusionStrategy strategy) {
<span class="fc" id="L499">    Objects.requireNonNull(strategy);</span>
<span class="fc" id="L500">    excluder = excluder.withExclusionStrategy(strategy, false, true);</span>
<span class="fc" id="L501">    return this;</span>
  }

  /**
   * Configures Gson to output JSON that fits in a page for pretty printing. This option only
   * affects JSON serialization.
   *
   * &lt;p&gt;This is a convenience method which simply calls {@link #setFormattingStyle(FormattingStyle)}
   * with {@link FormattingStyle#PRETTY}.
   *
   * @return a reference to this {@code GsonBuilder} object to fulfill the &quot;Builder&quot; pattern
   */
  @CanIgnoreReturnValue
  public GsonBuilder setPrettyPrinting() {
<span class="fc" id="L515">    return setFormattingStyle(FormattingStyle.PRETTY);</span>
  }

  /**
   * Configures Gson to output JSON that uses a certain kind of formatting style (for example
   * newline and indent). This option only affects JSON serialization. By default Gson produces
   * compact JSON output without any formatting.
   *
   * @param formattingStyle the formatting style to use.
   * @return a reference to this {@code GsonBuilder} object to fulfill the &quot;Builder&quot; pattern
   * @since 2.11.0
   */
  @CanIgnoreReturnValue
  public GsonBuilder setFormattingStyle(FormattingStyle formattingStyle) {
<span class="fc" id="L529">    this.formattingStyle = Objects.requireNonNull(formattingStyle);</span>
<span class="fc" id="L530">    return this;</span>
  }

  /**
   * Sets the strictness of this builder to {@link Strictness#LENIENT}.
   *
   * @deprecated This method is equivalent to calling {@link #setStrictness(Strictness)} with {@link
   *     Strictness#LENIENT}: {@code setStrictness(Strictness.LENIENT)}
   * @return a reference to this {@code GsonBuilder} object to fulfill the &quot;Builder&quot; pattern.
   * @see JsonReader#setStrictness(Strictness)
   * @see JsonWriter#setStrictness(Strictness)
   * @see #setStrictness(Strictness)
   */
  @Deprecated
  @InlineMe(
      replacement = &quot;this.setStrictness(Strictness.LENIENT)&quot;,
      imports = &quot;com.google.gson.Strictness&quot;)
  @CanIgnoreReturnValue
  public GsonBuilder setLenient() {
<span class="fc" id="L549">    return setStrictness(Strictness.LENIENT);</span>
  }

  /**
   * Sets the strictness of this builder to the provided parameter.
   *
   * &lt;p&gt;This changes how strict the &lt;a href=&quot;https://www.ietf.org/rfc/rfc8259.txt&quot;&gt;RFC 8259 JSON
   * specification&lt;/a&gt; is enforced when parsing or writing JSON. For details on this, refer to
   * {@link JsonReader#setStrictness(Strictness)} and {@link JsonWriter#setStrictness(Strictness)}.
   *
   * @param strictness the new strictness mode. May not be {@code null}.
   * @return a reference to this {@code GsonBuilder} object to fulfill the &quot;Builder&quot; pattern.
   * @see JsonReader#setStrictness(Strictness)
   * @see JsonWriter#setStrictness(Strictness)
   * @since 2.11.0
   */
  @CanIgnoreReturnValue
  public GsonBuilder setStrictness(Strictness strictness) {
<span class="fc" id="L567">    this.strictness = Objects.requireNonNull(strictness);</span>
<span class="fc" id="L568">    return this;</span>
  }

  /**
   * By default, Gson escapes HTML characters such as &amp;lt; &amp;gt; etc. Use this option to configure
   * Gson to pass-through HTML characters as is.
   *
   * @return a reference to this {@code GsonBuilder} object to fulfill the &quot;Builder&quot; pattern
   * @since 1.3
   */
  @CanIgnoreReturnValue
  public GsonBuilder disableHtmlEscaping() {
<span class="fc" id="L580">    this.escapeHtmlChars = false;</span>
<span class="fc" id="L581">    return this;</span>
  }

  /**
   * Configures Gson to serialize {@code Date} objects according to the pattern provided. You can
   * call this method or {@link #setDateFormat(int, int)} multiple times, but only the last
   * invocation will be used to decide the serialization format.
   *
   * &lt;p&gt;The date format will be used to serialize and deserialize {@link java.util.Date} and in case
   * the {@code java.sql} module is present, also {@link java.sql.Timestamp} and {@link
   * java.sql.Date}.
   *
   * &lt;p&gt;Note that this pattern must abide by the convention provided by {@code SimpleDateFormat}
   * class. See the documentation in {@link SimpleDateFormat} for more information on valid date and
   * time patterns.
   *
   * @param pattern the pattern that dates will be serialized/deserialized to/from; can be {@code
   *     null} to reset the pattern
   * @return a reference to this {@code GsonBuilder} object to fulfill the &quot;Builder&quot; pattern
   * @throws IllegalArgumentException if the pattern is invalid
   * @since 1.2
   */
  @CanIgnoreReturnValue
  public GsonBuilder setDateFormat(String pattern) {
<span class="fc bfc" id="L605" title="All 2 branches covered.">    if (pattern != null) {</span>
      try {
<span class="fc" id="L607">        new SimpleDateFormat(pattern);</span>
<span class="fc" id="L608">      } catch (IllegalArgumentException e) {</span>
        // Throw exception if it is an invalid date format
<span class="fc" id="L610">        throw new IllegalArgumentException(&quot;The date pattern '&quot; + pattern + &quot;' is not valid&quot;, e);</span>
<span class="fc" id="L611">      }</span>
    }
<span class="fc" id="L613">    this.datePattern = pattern;</span>
<span class="fc" id="L614">    return this;</span>
  }

  /**
   * Configures Gson to serialize {@code Date} objects according to the date style value provided.
   * You can call this method or {@link #setDateFormat(String)} multiple times, but only the last
   * invocation will be used to decide the serialization format. This methods leaves the current
   * 'time style' unchanged.
   *
   * &lt;p&gt;Note that this style value should be one of the predefined constants in the {@link
   * DateFormat} class, such as {@link DateFormat#MEDIUM}. See the documentation of the {@link
   * DateFormat} class for more information on the valid style constants.
   *
   * @deprecated Counterintuitively, despite this method taking only a 'date style' Gson will use a
   *     format which includes both date and time, with the 'time style' being the last value set by
   *     {@link #setDateFormat(int, int)}. Therefore prefer using {@link #setDateFormat(int, int)}
   *     and explicitly provide the desired 'time style'.
   * @param dateStyle the predefined date style that date objects will be serialized/deserialized
   *     to/from
   * @return a reference to this {@code GsonBuilder} object to fulfill the &quot;Builder&quot; pattern
   * @throws IllegalArgumentException if the style is invalid
   * @since 1.2
   */
  @Deprecated
  @CanIgnoreReturnValue
  public GsonBuilder setDateFormat(int dateStyle) {
<span class="fc" id="L640">    this.dateStyle = checkDateFormatStyle(dateStyle);</span>
<span class="fc" id="L641">    this.datePattern = null;</span>
<span class="fc" id="L642">    return this;</span>
  }

  /**
   * Configures Gson to serialize {@code Date} objects according to the style value provided. You
   * can call this method or {@link #setDateFormat(String)} multiple times, but only the last
   * invocation will be used to decide the serialization format.
   *
   * &lt;p&gt;Note that this style value should be one of the predefined constants in the {@link
   * DateFormat} class, such as {@link DateFormat#MEDIUM}. See the documentation of the {@link
   * DateFormat} class for more information on the valid style constants.
   *
   * @param dateStyle the predefined date style that date objects will be serialized/deserialized
   *     to/from
   * @param timeStyle the predefined style for the time portion of the date objects
   * @return a reference to this {@code GsonBuilder} object to fulfill the &quot;Builder&quot; pattern
   * @throws IllegalArgumentException if the style values are invalid
   * @since 1.2
   */
  @CanIgnoreReturnValue
  public GsonBuilder setDateFormat(int dateStyle, int timeStyle) {
<span class="fc" id="L663">    this.dateStyle = checkDateFormatStyle(dateStyle);</span>
<span class="fc" id="L664">    this.timeStyle = checkDateFormatStyle(timeStyle);</span>
<span class="fc" id="L665">    this.datePattern = null;</span>
<span class="fc" id="L666">    return this;</span>
  }

  private static int checkDateFormatStyle(int style) {
    // Valid DateFormat styles are: 0, 1, 2, 3 (FULL, LONG, MEDIUM, SHORT)
<span class="fc bfc" id="L671" title="All 4 branches covered.">    if (style &lt; 0 || style &gt; 3) {</span>
<span class="fc" id="L672">      throw new IllegalArgumentException(&quot;Invalid style: &quot; + style);</span>
    }
<span class="fc" id="L674">    return style;</span>
  }

  /**
   * Configures Gson for custom serialization or deserialization. This method combines the
   * registration of an {@link TypeAdapter}, {@link InstanceCreator}, {@link JsonSerializer}, and a
   * {@link JsonDeserializer}. It is best used when a single object {@code typeAdapter} implements
   * all the required interfaces for custom serialization with Gson. If a type adapter was
   * previously registered for the specified {@code type}, it is overwritten.
   *
   * &lt;p&gt;This registers the type specified and no other types: you must manually register related
   * types! For example, applications registering {@code boolean.class} should also register {@code
   * Boolean.class}. And when registering an adapter for a class which has subclasses, you might
   * also want to register the adapter for subclasses, or use {@link
   * #registerTypeHierarchyAdapter(Class, Object)} instead.
   *
   * &lt;p&gt;{@link JsonSerializer} and {@link JsonDeserializer} are made &quot;{@code null}-safe&quot;. This means
   * when trying to serialize {@code null}, Gson will write a JSON {@code null} and the serializer
   * is not called. Similarly when deserializing a JSON {@code null}, Gson will emit {@code null}
   * without calling the deserializer. If it is desired to handle {@code null} values, a {@link
   * TypeAdapter} should be used instead.
   *
   * @param type the type definition for the type adapter being registered
   * @param typeAdapter This object must implement at least one of the {@link TypeAdapter}, {@link
   *     InstanceCreator}, {@link JsonSerializer}, and a {@link JsonDeserializer} interfaces.
   * @return a reference to this {@code GsonBuilder} object to fulfill the &quot;Builder&quot; pattern
   * @throws IllegalArgumentException if the type adapter being registered is for {@code Object}
   *     class or {@link JsonElement} or any of its subclasses
   * @see #registerTypeHierarchyAdapter(Class, Object)
   */
  @CanIgnoreReturnValue
  public GsonBuilder registerTypeAdapter(Type type, Object typeAdapter) {
<span class="fc" id="L706">    Objects.requireNonNull(type);</span>
<span class="pc bpc" id="L707" title="1 of 8 branches missed.">    $Gson$Preconditions.checkArgument(</span>
        typeAdapter instanceof JsonSerializer&lt;?&gt;
            || typeAdapter instanceof JsonDeserializer&lt;?&gt;
            || typeAdapter instanceof InstanceCreator&lt;?&gt;
            || typeAdapter instanceof TypeAdapter&lt;?&gt;);

<span class="fc bfc" id="L713" title="All 2 branches covered.">    if (hasNonOverridableAdapter(type)) {</span>
<span class="fc" id="L714">      throw new IllegalArgumentException(&quot;Cannot override built-in adapter for &quot; + type);</span>
    }

<span class="fc bfc" id="L717" title="All 2 branches covered.">    if (typeAdapter instanceof InstanceCreator&lt;?&gt;) {</span>
<span class="fc" id="L718">      instanceCreators.put(type, (InstanceCreator&lt;?&gt;) typeAdapter);</span>
    }
<span class="fc bfc" id="L720" title="All 4 branches covered.">    if (typeAdapter instanceof JsonSerializer&lt;?&gt; || typeAdapter instanceof JsonDeserializer&lt;?&gt;) {</span>
<span class="fc" id="L721">      TypeToken&lt;?&gt; typeToken = TypeToken.get(type);</span>
<span class="fc" id="L722">      factories.add(TreeTypeAdapter.newFactoryWithMatchRawType(typeToken, typeAdapter));</span>
    }
<span class="fc bfc" id="L724" title="All 2 branches covered.">    if (typeAdapter instanceof TypeAdapter&lt;?&gt;) {</span>
      @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
<span class="fc" id="L726">      TypeAdapterFactory factory =</span>
<span class="fc" id="L727">          TypeAdapters.newFactory(TypeToken.get(type), (TypeAdapter) typeAdapter);</span>
<span class="fc" id="L728">      factories.add(factory);</span>
    }
<span class="fc" id="L730">    return this;</span>
  }

  /** Whether the type has a built-in adapter which cannot be overridden. */
  private static boolean hasNonOverridableAdapter(Type type) {
<span class="fc bfc" id="L735" title="All 2 branches covered.">    return type == Object.class;</span>
    // This should also cover `JsonElement.class.isAssignableFrom(type)`, however for backward
    // compatibility this is not covered here because really old Gson versions had no built-in
    // adapter for JsonElement so users registered custom adapters. These adapters don't have any
    // effect in recent Gson versions. See
    // https://github.com/google/gson/issues/2787#issuecomment-2581568157
  }

  /**
   * Registers a factory for type adapters. Registering a factory is useful when the type adapter
   * needs to be configured based on the type of the field being processed. Gson is designed to
   * handle a large number of factories, so you should consider registering them to be at par with
   * registering an individual type adapter.
   *
   * &lt;p&gt;The created Gson instance might only use the factory once to create an adapter for a
   * specific type and cache the result. It is not guaranteed that the factory will be used again
   * every time the type is serialized or deserialized.
   *
   * @since 2.1
   */
  @CanIgnoreReturnValue
  public GsonBuilder registerTypeAdapterFactory(TypeAdapterFactory factory) {
<span class="fc" id="L757">    Objects.requireNonNull(factory);</span>
<span class="fc" id="L758">    factories.add(factory);</span>
<span class="fc" id="L759">    return this;</span>
  }

  /**
   * Configures Gson for custom serialization or deserialization for an inheritance type hierarchy.
   * This method combines the registration of a {@link TypeAdapter}, {@link JsonSerializer} and a
   * {@link JsonDeserializer}. If a type adapter was previously registered for the specified type
   * hierarchy, it is overridden. If a type adapter is registered for a specific type in the type
   * hierarchy, it will be invoked instead of the one registered for the type hierarchy.
   *
   * @param baseType the class definition for the type adapter being registered for the base class
   *     or interface
   * @param typeAdapter This object must implement at least one of {@link TypeAdapter}, {@link
   *     JsonSerializer} or {@link JsonDeserializer} interfaces.
   * @return a reference to this {@code GsonBuilder} object to fulfill the &quot;Builder&quot; pattern
   * @throws IllegalArgumentException if the type adapter being registered is for {@link
   *     JsonElement} or any of its subclasses
   * @since 1.7
   */
  @CanIgnoreReturnValue
  public GsonBuilder registerTypeHierarchyAdapter(Class&lt;?&gt; baseType, Object typeAdapter) {
<span class="fc" id="L780">    Objects.requireNonNull(baseType);</span>
<span class="pc bpc" id="L781" title="1 of 6 branches missed.">    $Gson$Preconditions.checkArgument(</span>
        typeAdapter instanceof JsonSerializer&lt;?&gt;
            || typeAdapter instanceof JsonDeserializer&lt;?&gt;
            || typeAdapter instanceof TypeAdapter&lt;?&gt;);

<span class="fc bfc" id="L786" title="All 4 branches covered.">    if (typeAdapter instanceof JsonDeserializer || typeAdapter instanceof JsonSerializer) {</span>
<span class="fc" id="L787">      hierarchyFactories.add(TreeTypeAdapter.newTypeHierarchyFactory(baseType, typeAdapter));</span>
    }
<span class="fc bfc" id="L789" title="All 2 branches covered.">    if (typeAdapter instanceof TypeAdapter&lt;?&gt;) {</span>
      @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
<span class="fc" id="L791">      TypeAdapterFactory factory =</span>
<span class="fc" id="L792">          TypeAdapters.newTypeHierarchyFactory(baseType, (TypeAdapter) typeAdapter);</span>
<span class="fc" id="L793">      factories.add(factory);</span>
    }
<span class="fc" id="L795">    return this;</span>
  }

  /**
   * Section 6 of &lt;a href=&quot;https://www.ietf.org/rfc/rfc8259.txt&quot;&gt;JSON specification&lt;/a&gt; disallows
   * special double values (NaN, Infinity, -Infinity). However, &lt;a
   * href=&quot;http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf&quot;&gt;Javascript
   * specification&lt;/a&gt; (see section 4.3.20, 4.3.22, 4.3.23) allows these values as valid Javascript
   * values. Moreover, most JavaScript engines will accept these special values in JSON without
   * problem. So, at a practical level, it makes sense to accept these values as valid JSON even
   * though JSON specification disallows them.
   *
   * &lt;p&gt;Gson always accepts these special values during deserialization. However, it outputs
   * strictly compliant JSON. Hence, if it encounters a float value {@link Float#NaN}, {@link
   * Float#POSITIVE_INFINITY}, {@link Float#NEGATIVE_INFINITY}, or a double value {@link
   * Double#NaN}, {@link Double#POSITIVE_INFINITY}, {@link Double#NEGATIVE_INFINITY}, it will throw
   * an {@link IllegalArgumentException}. This method provides a way to override the default
   * behavior when you know that the JSON receiver will be able to handle these special values.
   *
   * @return a reference to this {@code GsonBuilder} object to fulfill the &quot;Builder&quot; pattern
   * @since 1.3
   */
  @CanIgnoreReturnValue
  public GsonBuilder serializeSpecialFloatingPointValues() {
<span class="fc" id="L819">    this.serializeSpecialFloatingPointValues = true;</span>
<span class="fc" id="L820">    return this;</span>
  }

  /**
   * Disables usage of JDK's {@code sun.misc.Unsafe}.
   *
   * &lt;p&gt;By default Gson uses {@code Unsafe} to create instances of classes which don't have a
   * no-args constructor. However, {@code Unsafe} might not be available for all Java runtimes. For
   * example Android does not provide {@code Unsafe}, or only with limited functionality.
   * Additionally {@code Unsafe} creates instances without executing any constructor or initializer
   * block, or performing initialization of field values. This can lead to surprising and difficult
   * to debug errors. Therefore, to get reliable behavior regardless of which runtime is used, and
   * to detect classes which cannot be deserialized in an early stage of development, this method
   * allows disabling usage of {@code Unsafe}.
   *
   * @return a reference to this {@code GsonBuilder} object to fulfill the &quot;Builder&quot; pattern
   * @since 2.9.0
   */
  @CanIgnoreReturnValue
  public GsonBuilder disableJdkUnsafe() {
<span class="fc" id="L840">    this.useJdkUnsafe = false;</span>
<span class="fc" id="L841">    return this;</span>
  }

  /**
   * Adds a reflection access filter. A reflection access filter prevents Gson from using reflection
   * for the serialization and deserialization of certain classes. The logic in the filter specifies
   * which classes those are.
   *
   * &lt;p&gt;Filters will be invoked in reverse registration order, that is, the most recently added
   * filter will be invoked first.
   *
   * &lt;p&gt;By default Gson has no filters configured and will try to use reflection for all classes for
   * which no {@link TypeAdapter} has been registered, and for which no built-in Gson {@code
   * TypeAdapter} exists.
   *
   * &lt;p&gt;The created Gson instance might only use an access filter once for a class or its members
   * and cache the result. It is not guaranteed that the filter will be used again every time a
   * class or its members are accessed during serialization or deserialization.
   *
   * @param filter filter to add
   * @return a reference to this {@code GsonBuilder} object to fulfill the &quot;Builder&quot; pattern
   * @since 2.9.1
   */
  @CanIgnoreReturnValue
  public GsonBuilder addReflectionAccessFilter(ReflectionAccessFilter filter) {
<span class="fc" id="L866">    Objects.requireNonNull(filter);</span>
<span class="fc" id="L867">    reflectionFilters.addFirst(filter);</span>
<span class="fc" id="L868">    return this;</span>
  }

  /**
   * Creates a {@link Gson} instance based on the current configuration. This method is free of
   * side-effects to this {@code GsonBuilder} instance and hence can be called multiple times.
   *
   * @return an instance of Gson configured with the options currently set in this builder
   */
  public Gson create() {
<span class="fc" id="L878">    List&lt;TypeAdapterFactory&gt; factories =</span>
<span class="fc" id="L879">        new ArrayList&lt;&gt;(this.factories.size() + this.hierarchyFactories.size() + 3);</span>
<span class="fc" id="L880">    factories.addAll(this.factories);</span>
<span class="fc" id="L881">    Collections.reverse(factories);</span>

<span class="fc" id="L883">    List&lt;TypeAdapterFactory&gt; hierarchyFactories = new ArrayList&lt;&gt;(this.hierarchyFactories);</span>
<span class="fc" id="L884">    Collections.reverse(hierarchyFactories);</span>
<span class="fc" id="L885">    factories.addAll(hierarchyFactories);</span>

<span class="fc" id="L887">    addTypeAdaptersForDate(datePattern, dateStyle, timeStyle, factories);</span>

<span class="fc" id="L889">    return new Gson(</span>
        excluder,
        fieldNamingPolicy,
        new HashMap&lt;&gt;(instanceCreators),
        serializeNulls,
        complexMapKeySerialization,
        generateNonExecutableJson,
        escapeHtmlChars,
        formattingStyle,
        strictness,
        serializeSpecialFloatingPointValues,
        useJdkUnsafe,
        longSerializationPolicy,
        datePattern,
        dateStyle,
        timeStyle,
        new ArrayList&lt;&gt;(this.factories),
        new ArrayList&lt;&gt;(this.hierarchyFactories),
        factories,
        objectToNumberStrategy,
        numberToNumberStrategy,
        new ArrayList&lt;&gt;(reflectionFilters));
  }

  private static void addTypeAdaptersForDate(
      String datePattern, int dateStyle, int timeStyle, List&lt;TypeAdapterFactory&gt; factories) {
    TypeAdapterFactory dateAdapterFactory;
<span class="fc" id="L916">    boolean sqlTypesSupported = SqlTypesSupport.SUPPORTS_SQL_TYPES;</span>
<span class="fc" id="L917">    TypeAdapterFactory sqlTimestampAdapterFactory = null;</span>
<span class="fc" id="L918">    TypeAdapterFactory sqlDateAdapterFactory = null;</span>

<span class="fc bfc" id="L920" title="All 4 branches covered.">    if (datePattern != null &amp;&amp; !datePattern.trim().isEmpty()) {</span>
<span class="fc" id="L921">      dateAdapterFactory = DefaultDateTypeAdapter.DateType.DATE.createAdapterFactory(datePattern);</span>

<span class="pc bpc" id="L923" title="1 of 2 branches missed.">      if (sqlTypesSupported) {</span>
<span class="fc" id="L924">        sqlTimestampAdapterFactory =</span>
<span class="fc" id="L925">            SqlTypesSupport.TIMESTAMP_DATE_TYPE.createAdapterFactory(datePattern);</span>
<span class="fc" id="L926">        sqlDateAdapterFactory = SqlTypesSupport.DATE_DATE_TYPE.createAdapterFactory(datePattern);</span>
      }
<span class="fc bfc" id="L928" title="All 4 branches covered.">    } else if (dateStyle != DateFormat.DEFAULT || timeStyle != DateFormat.DEFAULT) {</span>
<span class="fc" id="L929">      dateAdapterFactory =</span>
<span class="fc" id="L930">          DefaultDateTypeAdapter.DateType.DATE.createAdapterFactory(dateStyle, timeStyle);</span>

<span class="pc bpc" id="L932" title="1 of 2 branches missed.">      if (sqlTypesSupported) {</span>
<span class="fc" id="L933">        sqlTimestampAdapterFactory =</span>
<span class="fc" id="L934">            SqlTypesSupport.TIMESTAMP_DATE_TYPE.createAdapterFactory(dateStyle, timeStyle);</span>
<span class="fc" id="L935">        sqlDateAdapterFactory =</span>
<span class="fc" id="L936">            SqlTypesSupport.DATE_DATE_TYPE.createAdapterFactory(dateStyle, timeStyle);</span>
      }
    } else {
<span class="fc" id="L939">      return;</span>
    }

<span class="fc" id="L942">    factories.add(dateAdapterFactory);</span>
<span class="pc bpc" id="L943" title="1 of 2 branches missed.">    if (sqlTypesSupported) {</span>
<span class="fc" id="L944">      factories.add(sqlTimestampAdapterFactory);</span>
<span class="fc" id="L945">      factories.add(sqlDateAdapterFactory);</span>
    }
<span class="fc" id="L947">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>