<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="sv"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TypeAdapters.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Gson</a> &gt; <a href="index.source.html" class="el_package">com.google.gson.internal.bind</a> &gt; <span class="el_source">TypeAdapters.java</span></div><h1>TypeAdapters.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.gson.internal.bind;

import com.google.gson.Gson;
import com.google.gson.JsonElement;
import com.google.gson.JsonIOException;
import com.google.gson.JsonSyntaxException;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.internal.LazilyParsedNumber;
import com.google.gson.internal.NumberLimits;
import com.google.gson.internal.TroubleshootingGuide;
import com.google.gson.reflect.TypeToken;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonToken;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.net.InetAddress;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.util.ArrayList;
import java.util.BitSet;
import java.util.Calendar;
import java.util.Currency;
import java.util.GregorianCalendar;
import java.util.List;
import java.util.Locale;
import java.util.StringTokenizer;
import java.util.UUID;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicIntegerArray;

/**
 * Type adapters for basic types. More complex adapters exist as separate classes in the enclosing
 * package.
 */
public final class TypeAdapters {
<span class="nc" id="L57">  private TypeAdapters() {</span>
<span class="nc" id="L58">    throw new UnsupportedOperationException();</span>
  }

  @SuppressWarnings(&quot;rawtypes&quot;)
<span class="fc" id="L62">  public static final TypeAdapter&lt;Class&gt; CLASS =</span>
<span class="fc" id="L63">      new TypeAdapter&lt;Class&gt;() {</span>
        @Override
        public void write(JsonWriter out, Class value) throws IOException {
<span class="fc" id="L66">          throw new UnsupportedOperationException(</span>
              &quot;Attempted to serialize java.lang.Class: &quot;
<span class="fc" id="L68">                  + value.getName()</span>
                  + &quot;. Forgot to register a type adapter?&quot;
                  + &quot;\nSee &quot;
<span class="fc" id="L71">                  + TroubleshootingGuide.createUrl(&quot;java-lang-class-unsupported&quot;));</span>
        }

        @Override
        public Class read(JsonReader in) throws IOException {
<span class="fc" id="L76">          throw new UnsupportedOperationException(</span>
              &quot;Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?&quot;
                  + &quot;\nSee &quot;
<span class="fc" id="L79">                  + TroubleshootingGuide.createUrl(&quot;java-lang-class-unsupported&quot;));</span>
        }
<span class="fc" id="L81">      }.nullSafe();</span>

<span class="fc" id="L83">  public static final TypeAdapterFactory CLASS_FACTORY = newFactory(Class.class, CLASS);</span>

<span class="fc" id="L85">  public static final TypeAdapter&lt;BitSet&gt; BIT_SET =</span>
<span class="fc" id="L86">      new TypeAdapter&lt;BitSet&gt;() {</span>
        @Override
        public BitSet read(JsonReader in) throws IOException {
<span class="fc" id="L89">          BitSet bitset = new BitSet();</span>
<span class="fc" id="L90">          in.beginArray();</span>
<span class="fc" id="L91">          int i = 0;</span>
<span class="fc" id="L92">          JsonToken tokenType = in.peek();</span>
<span class="fc bfc" id="L93" title="All 2 branches covered.">          while (tokenType != JsonToken.END_ARRAY) {</span>
            boolean set;
<span class="fc bfc" id="L95" title="All 3 branches covered.">            switch (tokenType) {</span>
              case NUMBER:
              case STRING:
<span class="fc" id="L98">                int intValue = in.nextInt();</span>
<span class="fc bfc" id="L99" title="All 2 branches covered.">                if (intValue == 0) {</span>
<span class="fc" id="L100">                  set = false;</span>
<span class="fc bfc" id="L101" title="All 2 branches covered.">                } else if (intValue == 1) {</span>
<span class="fc" id="L102">                  set = true;</span>
                } else {
<span class="fc" id="L104">                  throw new JsonSyntaxException(</span>
                      &quot;Invalid bitset value &quot;
                          + intValue
                          + &quot;, expected 0 or 1; at path &quot;
<span class="fc" id="L108">                          + in.getPreviousPath());</span>
                }
                break;
              case BOOLEAN:
<span class="fc" id="L112">                set = in.nextBoolean();</span>
<span class="fc" id="L113">                break;</span>
              default:
<span class="fc" id="L115">                throw new JsonSyntaxException(</span>
<span class="fc" id="L116">                    &quot;Invalid bitset value type: &quot; + tokenType + &quot;; at path &quot; + in.getPath());</span>
            }
<span class="fc bfc" id="L118" title="All 2 branches covered.">            if (set) {</span>
<span class="fc" id="L119">              bitset.set(i);</span>
            }
<span class="fc" id="L121">            ++i;</span>
<span class="fc" id="L122">            tokenType = in.peek();</span>
<span class="fc" id="L123">          }</span>
<span class="fc" id="L124">          in.endArray();</span>
<span class="fc" id="L125">          return bitset;</span>
        }

        @Override
        public void write(JsonWriter out, BitSet src) throws IOException {
<span class="fc" id="L130">          out.beginArray();</span>
<span class="fc bfc" id="L131" title="All 2 branches covered.">          for (int i = 0, length = src.length(); i &lt; length; i++) {</span>
<span class="fc bfc" id="L132" title="All 2 branches covered.">            int value = src.get(i) ? 1 : 0;</span>
<span class="fc" id="L133">            out.value(value);</span>
          }
<span class="fc" id="L135">          out.endArray();</span>
<span class="fc" id="L136">        }</span>
<span class="fc" id="L137">      }.nullSafe();</span>

<span class="fc" id="L139">  public static final TypeAdapterFactory BIT_SET_FACTORY = newFactory(BitSet.class, BIT_SET);</span>

<span class="fc" id="L141">  public static final TypeAdapter&lt;Boolean&gt; BOOLEAN =</span>
<span class="fc" id="L142">      new TypeAdapter&lt;Boolean&gt;() {</span>
        @Override
        public Boolean read(JsonReader in) throws IOException {
<span class="fc" id="L145">          JsonToken peek = in.peek();</span>
<span class="fc bfc" id="L146" title="All 2 branches covered.">          if (peek == JsonToken.NULL) {</span>
<span class="fc" id="L147">            in.nextNull();</span>
<span class="fc" id="L148">            return null;</span>
<span class="fc bfc" id="L149" title="All 2 branches covered.">          } else if (peek == JsonToken.STRING) {</span>
            // support strings for compatibility with GSON 1.7
<span class="fc" id="L151">            return Boolean.parseBoolean(in.nextString());</span>
          }
<span class="fc" id="L153">          return in.nextBoolean();</span>
        }

        @Override
        public void write(JsonWriter out, Boolean value) throws IOException {
<span class="fc" id="L158">          out.value(value);</span>
<span class="fc" id="L159">        }</span>
      };

  /**
   * Writes a boolean as a string. Useful for map keys, where booleans aren't otherwise permitted.
   */
<span class="fc" id="L165">  public static final TypeAdapter&lt;Boolean&gt; BOOLEAN_AS_STRING =</span>
<span class="fc" id="L166">      new TypeAdapter&lt;Boolean&gt;() {</span>
        @Override
        public Boolean read(JsonReader in) throws IOException {
<span class="pc bpc" id="L169" title="1 of 2 branches missed.">          if (in.peek() == JsonToken.NULL) {</span>
<span class="nc" id="L170">            in.nextNull();</span>
<span class="nc" id="L171">            return null;</span>
          }
<span class="fc" id="L173">          return Boolean.valueOf(in.nextString());</span>
        }

        @Override
        public void write(JsonWriter out, Boolean value) throws IOException {
<span class="nc bnc" id="L178" title="All 2 branches missed.">          out.value(value == null ? &quot;null&quot; : value.toString());</span>
<span class="nc" id="L179">        }</span>
      };

<span class="fc" id="L182">  public static final TypeAdapterFactory BOOLEAN_FACTORY =</span>
<span class="fc" id="L183">      newFactory(boolean.class, Boolean.class, BOOLEAN);</span>

<span class="fc" id="L185">  public static final TypeAdapter&lt;Number&gt; BYTE =</span>
<span class="fc" id="L186">      new TypeAdapter&lt;Number&gt;() {</span>
        @Override
        public Number read(JsonReader in) throws IOException {
<span class="fc bfc" id="L189" title="All 2 branches covered.">          if (in.peek() == JsonToken.NULL) {</span>
<span class="fc" id="L190">            in.nextNull();</span>
<span class="fc" id="L191">            return null;</span>
          }

          int intValue;
          try {
<span class="fc" id="L196">            intValue = in.nextInt();</span>
<span class="fc" id="L197">          } catch (NumberFormatException e) {</span>
<span class="fc" id="L198">            throw new JsonSyntaxException(e);</span>
<span class="fc" id="L199">          }</span>
          // Allow up to 255 to support unsigned values
<span class="fc bfc" id="L201" title="All 4 branches covered.">          if (intValue &gt; 255 || intValue &lt; Byte.MIN_VALUE) {</span>
<span class="fc" id="L202">            throw new JsonSyntaxException(</span>
<span class="fc" id="L203">                &quot;Lossy conversion from &quot; + intValue + &quot; to byte; at path &quot; + in.getPreviousPath());</span>
          }
<span class="fc" id="L205">          return (byte) intValue;</span>
        }

        @Override
        public void write(JsonWriter out, Number value) throws IOException {
<span class="fc bfc" id="L210" title="All 2 branches covered.">          if (value == null) {</span>
<span class="fc" id="L211">            out.nullValue();</span>
          } else {
<span class="fc" id="L213">            out.value(value.byteValue());</span>
          }
<span class="fc" id="L215">        }</span>
      };

<span class="fc" id="L218">  public static final TypeAdapterFactory BYTE_FACTORY = newFactory(byte.class, Byte.class, BYTE);</span>

<span class="fc" id="L220">  public static final TypeAdapter&lt;Number&gt; SHORT =</span>
<span class="fc" id="L221">      new TypeAdapter&lt;Number&gt;() {</span>
        @Override
        public Number read(JsonReader in) throws IOException {
<span class="fc bfc" id="L224" title="All 2 branches covered.">          if (in.peek() == JsonToken.NULL) {</span>
<span class="fc" id="L225">            in.nextNull();</span>
<span class="fc" id="L226">            return null;</span>
          }

          int intValue;
          try {
<span class="fc" id="L231">            intValue = in.nextInt();</span>
<span class="fc" id="L232">          } catch (NumberFormatException e) {</span>
<span class="fc" id="L233">            throw new JsonSyntaxException(e);</span>
<span class="fc" id="L234">          }</span>
          // Allow up to 65535 to support unsigned values
<span class="fc bfc" id="L236" title="All 4 branches covered.">          if (intValue &gt; 65535 || intValue &lt; Short.MIN_VALUE) {</span>
<span class="fc" id="L237">            throw new JsonSyntaxException(</span>
<span class="fc" id="L238">                &quot;Lossy conversion from &quot; + intValue + &quot; to short; at path &quot; + in.getPreviousPath());</span>
          }
<span class="fc" id="L240">          return (short) intValue;</span>
        }

        @Override
        public void write(JsonWriter out, Number value) throws IOException {
<span class="fc bfc" id="L245" title="All 2 branches covered.">          if (value == null) {</span>
<span class="fc" id="L246">            out.nullValue();</span>
          } else {
<span class="fc" id="L248">            out.value(value.shortValue());</span>
          }
<span class="fc" id="L250">        }</span>
      };

<span class="fc" id="L253">  public static final TypeAdapterFactory SHORT_FACTORY =</span>
<span class="fc" id="L254">      newFactory(short.class, Short.class, SHORT);</span>

<span class="fc" id="L256">  public static final TypeAdapter&lt;Number&gt; INTEGER =</span>
<span class="fc" id="L257">      new TypeAdapter&lt;Number&gt;() {</span>
        @Override
        public Number read(JsonReader in) throws IOException {
<span class="fc bfc" id="L260" title="All 2 branches covered.">          if (in.peek() == JsonToken.NULL) {</span>
<span class="fc" id="L261">            in.nextNull();</span>
<span class="fc" id="L262">            return null;</span>
          }
          try {
<span class="fc" id="L265">            return in.nextInt();</span>
<span class="fc" id="L266">          } catch (NumberFormatException e) {</span>
<span class="fc" id="L267">            throw new JsonSyntaxException(e);</span>
          }
        }

        @Override
        public void write(JsonWriter out, Number value) throws IOException {
<span class="fc bfc" id="L273" title="All 2 branches covered.">          if (value == null) {</span>
<span class="fc" id="L274">            out.nullValue();</span>
          } else {
<span class="fc" id="L276">            out.value(value.intValue());</span>
          }
<span class="fc" id="L278">        }</span>
      };
<span class="fc" id="L280">  public static final TypeAdapterFactory INTEGER_FACTORY =</span>
<span class="fc" id="L281">      newFactory(int.class, Integer.class, INTEGER);</span>

<span class="fc" id="L283">  public static final TypeAdapter&lt;AtomicInteger&gt; ATOMIC_INTEGER =</span>
<span class="fc" id="L284">      new TypeAdapter&lt;AtomicInteger&gt;() {</span>
        @Override
        public AtomicInteger read(JsonReader in) throws IOException {
          try {
<span class="fc" id="L288">            return new AtomicInteger(in.nextInt());</span>
<span class="nc" id="L289">          } catch (NumberFormatException e) {</span>
<span class="nc" id="L290">            throw new JsonSyntaxException(e);</span>
          }
        }

        @Override
        public void write(JsonWriter out, AtomicInteger value) throws IOException {
<span class="fc" id="L296">          out.value(value.get());</span>
<span class="fc" id="L297">        }</span>
<span class="fc" id="L298">      }.nullSafe();</span>
<span class="fc" id="L299">  public static final TypeAdapterFactory ATOMIC_INTEGER_FACTORY =</span>
<span class="fc" id="L300">      newFactory(AtomicInteger.class, TypeAdapters.ATOMIC_INTEGER);</span>

<span class="fc" id="L302">  public static final TypeAdapter&lt;AtomicBoolean&gt; ATOMIC_BOOLEAN =</span>
<span class="fc" id="L303">      new TypeAdapter&lt;AtomicBoolean&gt;() {</span>
        @Override
        public AtomicBoolean read(JsonReader in) throws IOException {
<span class="fc" id="L306">          return new AtomicBoolean(in.nextBoolean());</span>
        }

        @Override
        public void write(JsonWriter out, AtomicBoolean value) throws IOException {
<span class="fc" id="L311">          out.value(value.get());</span>
<span class="fc" id="L312">        }</span>
<span class="fc" id="L313">      }.nullSafe();</span>
<span class="fc" id="L314">  public static final TypeAdapterFactory ATOMIC_BOOLEAN_FACTORY =</span>
<span class="fc" id="L315">      newFactory(AtomicBoolean.class, TypeAdapters.ATOMIC_BOOLEAN);</span>

<span class="fc" id="L317">  public static final TypeAdapter&lt;AtomicIntegerArray&gt; ATOMIC_INTEGER_ARRAY =</span>
<span class="fc" id="L318">      new TypeAdapter&lt;AtomicIntegerArray&gt;() {</span>
        @Override
        public AtomicIntegerArray read(JsonReader in) throws IOException {
<span class="fc" id="L321">          List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L322">          in.beginArray();</span>
<span class="fc bfc" id="L323" title="All 2 branches covered.">          while (in.hasNext()) {</span>
            try {
<span class="fc" id="L325">              int integer = in.nextInt();</span>
<span class="fc" id="L326">              list.add(integer);</span>
<span class="nc" id="L327">            } catch (NumberFormatException e) {</span>
<span class="nc" id="L328">              throw new JsonSyntaxException(e);</span>
<span class="fc" id="L329">            }</span>
          }
<span class="fc" id="L331">          in.endArray();</span>
<span class="fc" id="L332">          int length = list.size();</span>
<span class="fc" id="L333">          AtomicIntegerArray array = new AtomicIntegerArray(length);</span>
<span class="fc bfc" id="L334" title="All 2 branches covered.">          for (int i = 0; i &lt; length; ++i) {</span>
<span class="fc" id="L335">            array.set(i, list.get(i));</span>
          }
<span class="fc" id="L337">          return array;</span>
        }

        @Override
        public void write(JsonWriter out, AtomicIntegerArray value) throws IOException {
<span class="fc" id="L342">          out.beginArray();</span>
<span class="fc bfc" id="L343" title="All 2 branches covered.">          for (int i = 0, length = value.length(); i &lt; length; i++) {</span>
<span class="fc" id="L344">            out.value(value.get(i));</span>
          }
<span class="fc" id="L346">          out.endArray();</span>
<span class="fc" id="L347">        }</span>
<span class="fc" id="L348">      }.nullSafe();</span>
<span class="fc" id="L349">  public static final TypeAdapterFactory ATOMIC_INTEGER_ARRAY_FACTORY =</span>
<span class="fc" id="L350">      newFactory(AtomicIntegerArray.class, TypeAdapters.ATOMIC_INTEGER_ARRAY);</span>

<span class="fc" id="L352">  public static final TypeAdapter&lt;Number&gt; LONG =</span>
<span class="fc" id="L353">      new TypeAdapter&lt;Number&gt;() {</span>
        @Override
        public Number read(JsonReader in) throws IOException {
<span class="fc bfc" id="L356" title="All 2 branches covered.">          if (in.peek() == JsonToken.NULL) {</span>
<span class="fc" id="L357">            in.nextNull();</span>
<span class="fc" id="L358">            return null;</span>
          }
          try {
<span class="fc" id="L361">            return in.nextLong();</span>
<span class="fc" id="L362">          } catch (NumberFormatException e) {</span>
<span class="fc" id="L363">            throw new JsonSyntaxException(e);</span>
          }
        }

        @Override
        public void write(JsonWriter out, Number value) throws IOException {
<span class="fc bfc" id="L369" title="All 2 branches covered.">          if (value == null) {</span>
<span class="fc" id="L370">            out.nullValue();</span>
          } else {
<span class="fc" id="L372">            out.value(value.longValue());</span>
          }
<span class="fc" id="L374">        }</span>
      };

<span class="fc" id="L377">  public static final TypeAdapter&lt;Number&gt; FLOAT =</span>
<span class="fc" id="L378">      new TypeAdapter&lt;Number&gt;() {</span>
        @Override
        public Number read(JsonReader in) throws IOException {
<span class="nc bnc" id="L381" title="All 2 branches missed.">          if (in.peek() == JsonToken.NULL) {</span>
<span class="nc" id="L382">            in.nextNull();</span>
<span class="nc" id="L383">            return null;</span>
          }
<span class="nc" id="L385">          return (float) in.nextDouble();</span>
        }

        @Override
        public void write(JsonWriter out, Number value) throws IOException {
<span class="pc bpc" id="L390" title="1 of 2 branches missed.">          if (value == null) {</span>
<span class="nc" id="L391">            out.nullValue();</span>
          } else {
            // For backward compatibility don't call `JsonWriter.value(float)` because that method
            // has been newly added and not all custom JsonWriter implementations might override
            // it yet
<span class="fc bfc" id="L396" title="All 2 branches covered.">            Number floatNumber = value instanceof Float ? value : value.floatValue();</span>
<span class="fc" id="L397">            out.value(floatNumber);</span>
          }
<span class="fc" id="L399">        }</span>
      };

<span class="fc" id="L402">  public static final TypeAdapter&lt;Number&gt; DOUBLE =</span>
<span class="fc" id="L403">      new TypeAdapter&lt;Number&gt;() {</span>
        @Override
        public Number read(JsonReader in) throws IOException {
<span class="nc bnc" id="L406" title="All 2 branches missed.">          if (in.peek() == JsonToken.NULL) {</span>
<span class="nc" id="L407">            in.nextNull();</span>
<span class="nc" id="L408">            return null;</span>
          }
<span class="nc" id="L410">          return in.nextDouble();</span>
        }

        @Override
        public void write(JsonWriter out, Number value) throws IOException {
<span class="pc bpc" id="L415" title="1 of 2 branches missed.">          if (value == null) {</span>
<span class="nc" id="L416">            out.nullValue();</span>
          } else {
<span class="fc" id="L418">            out.value(value.doubleValue());</span>
          }
<span class="fc" id="L420">        }</span>
      };

<span class="fc" id="L423">  public static final TypeAdapter&lt;Character&gt; CHARACTER =</span>
<span class="fc" id="L424">      new TypeAdapter&lt;Character&gt;() {</span>
        @Override
        public Character read(JsonReader in) throws IOException {
<span class="fc bfc" id="L427" title="All 2 branches covered.">          if (in.peek() == JsonToken.NULL) {</span>
<span class="fc" id="L428">            in.nextNull();</span>
<span class="fc" id="L429">            return null;</span>
          }
<span class="fc" id="L431">          String str = in.nextString();</span>
<span class="pc bpc" id="L432" title="1 of 2 branches missed.">          if (str.length() != 1) {</span>
<span class="nc" id="L433">            throw new JsonSyntaxException(</span>
<span class="nc" id="L434">                &quot;Expecting character, got: &quot; + str + &quot;; at &quot; + in.getPreviousPath());</span>
          }
<span class="fc" id="L436">          return str.charAt(0);</span>
        }

        @Override
        public void write(JsonWriter out, Character value) throws IOException {
<span class="fc bfc" id="L441" title="All 2 branches covered.">          out.value(value == null ? null : String.valueOf(value));</span>
<span class="fc" id="L442">        }</span>
      };

<span class="fc" id="L445">  public static final TypeAdapterFactory CHARACTER_FACTORY =</span>
<span class="fc" id="L446">      newFactory(char.class, Character.class, CHARACTER);</span>

<span class="fc" id="L448">  public static final TypeAdapter&lt;String&gt; STRING =</span>
<span class="fc" id="L449">      new TypeAdapter&lt;String&gt;() {</span>
        @Override
        public String read(JsonReader in) throws IOException {
<span class="fc" id="L452">          JsonToken peek = in.peek();</span>
<span class="fc bfc" id="L453" title="All 2 branches covered.">          if (peek == JsonToken.NULL) {</span>
<span class="fc" id="L454">            in.nextNull();</span>
<span class="fc" id="L455">            return null;</span>
          }
          /* coerce booleans to strings for backwards compatibility */
<span class="fc bfc" id="L458" title="All 2 branches covered.">          if (peek == JsonToken.BOOLEAN) {</span>
<span class="fc" id="L459">            return Boolean.toString(in.nextBoolean());</span>
          }
<span class="fc" id="L461">          return in.nextString();</span>
        }

        @Override
        public void write(JsonWriter out, String value) throws IOException {
<span class="fc" id="L466">          out.value(value);</span>
<span class="fc" id="L467">        }</span>
      };

<span class="fc" id="L470">  public static final TypeAdapter&lt;BigDecimal&gt; BIG_DECIMAL =</span>
<span class="fc" id="L471">      new TypeAdapter&lt;BigDecimal&gt;() {</span>
        @Override
        public BigDecimal read(JsonReader in) throws IOException {
<span class="fc bfc" id="L474" title="All 2 branches covered.">          if (in.peek() == JsonToken.NULL) {</span>
<span class="fc" id="L475">            in.nextNull();</span>
<span class="fc" id="L476">            return null;</span>
          }
<span class="fc" id="L478">          String s = in.nextString();</span>
          try {
<span class="fc" id="L480">            return NumberLimits.parseBigDecimal(s);</span>
<span class="fc" id="L481">          } catch (NumberFormatException e) {</span>
<span class="fc" id="L482">            throw new JsonSyntaxException(</span>
<span class="fc" id="L483">                &quot;Failed parsing '&quot; + s + &quot;' as BigDecimal; at path &quot; + in.getPreviousPath(), e);</span>
          }
        }

        @Override
        public void write(JsonWriter out, BigDecimal value) throws IOException {
<span class="fc" id="L489">          out.value(value);</span>
<span class="fc" id="L490">        }</span>
      };

<span class="fc" id="L493">  public static final TypeAdapter&lt;BigInteger&gt; BIG_INTEGER =</span>
<span class="fc" id="L494">      new TypeAdapter&lt;BigInteger&gt;() {</span>
        @Override
        public BigInteger read(JsonReader in) throws IOException {
<span class="fc bfc" id="L497" title="All 2 branches covered.">          if (in.peek() == JsonToken.NULL) {</span>
<span class="fc" id="L498">            in.nextNull();</span>
<span class="fc" id="L499">            return null;</span>
          }
<span class="fc" id="L501">          String s = in.nextString();</span>
          try {
<span class="fc" id="L503">            return NumberLimits.parseBigInteger(s);</span>
<span class="fc" id="L504">          } catch (NumberFormatException e) {</span>
<span class="fc" id="L505">            throw new JsonSyntaxException(</span>
<span class="fc" id="L506">                &quot;Failed parsing '&quot; + s + &quot;' as BigInteger; at path &quot; + in.getPreviousPath(), e);</span>
          }
        }

        @Override
        public void write(JsonWriter out, BigInteger value) throws IOException {
<span class="fc" id="L512">          out.value(value);</span>
<span class="fc" id="L513">        }</span>
      };

<span class="fc" id="L516">  public static final TypeAdapter&lt;LazilyParsedNumber&gt; LAZILY_PARSED_NUMBER =</span>
<span class="fc" id="L517">      new TypeAdapter&lt;LazilyParsedNumber&gt;() {</span>
        // Normally users should not be able to access and deserialize LazilyParsedNumber because
        // it is an internal type, but implement this nonetheless in case there are legit corner
        // cases where this is possible
        @Override
        public LazilyParsedNumber read(JsonReader in) throws IOException {
<span class="pc bpc" id="L523" title="1 of 2 branches missed.">          if (in.peek() == JsonToken.NULL) {</span>
<span class="nc" id="L524">            in.nextNull();</span>
<span class="nc" id="L525">            return null;</span>
          }
<span class="fc" id="L527">          return new LazilyParsedNumber(in.nextString());</span>
        }

        @Override
        public void write(JsonWriter out, LazilyParsedNumber value) throws IOException {
<span class="fc" id="L532">          out.value(value);</span>
<span class="fc" id="L533">        }</span>
      };

<span class="fc" id="L536">  public static final TypeAdapterFactory STRING_FACTORY = newFactory(String.class, STRING);</span>

<span class="fc" id="L538">  public static final TypeAdapter&lt;StringBuilder&gt; STRING_BUILDER =</span>
<span class="fc" id="L539">      new TypeAdapter&lt;StringBuilder&gt;() {</span>
        @Override
        public StringBuilder read(JsonReader in) throws IOException {
<span class="fc bfc" id="L542" title="All 2 branches covered.">          if (in.peek() == JsonToken.NULL) {</span>
<span class="fc" id="L543">            in.nextNull();</span>
<span class="fc" id="L544">            return null;</span>
          }
<span class="fc" id="L546">          return new StringBuilder(in.nextString());</span>
        }

        @Override
        public void write(JsonWriter out, StringBuilder value) throws IOException {
<span class="fc bfc" id="L551" title="All 2 branches covered.">          out.value(value == null ? null : value.toString());</span>
<span class="fc" id="L552">        }</span>
      };

<span class="fc" id="L555">  public static final TypeAdapterFactory STRING_BUILDER_FACTORY =</span>
<span class="fc" id="L556">      newFactory(StringBuilder.class, STRING_BUILDER);</span>

<span class="fc" id="L558">  public static final TypeAdapter&lt;StringBuffer&gt; STRING_BUFFER =</span>
<span class="fc" id="L559">      new TypeAdapter&lt;StringBuffer&gt;() {</span>
        @Override
        public StringBuffer read(JsonReader in) throws IOException {
<span class="fc bfc" id="L562" title="All 2 branches covered.">          if (in.peek() == JsonToken.NULL) {</span>
<span class="fc" id="L563">            in.nextNull();</span>
<span class="fc" id="L564">            return null;</span>
          }
<span class="fc" id="L566">          return new StringBuffer(in.nextString());</span>
        }

        @Override
        public void write(JsonWriter out, StringBuffer value) throws IOException {
<span class="fc bfc" id="L571" title="All 2 branches covered.">          out.value(value == null ? null : value.toString());</span>
<span class="fc" id="L572">        }</span>
      };

<span class="fc" id="L575">  public static final TypeAdapterFactory STRING_BUFFER_FACTORY =</span>
<span class="fc" id="L576">      newFactory(StringBuffer.class, STRING_BUFFER);</span>

<span class="fc" id="L578">  public static final TypeAdapter&lt;URL&gt; URL =</span>
<span class="fc" id="L579">      new TypeAdapter&lt;URL&gt;() {</span>
        @Override
        public URL read(JsonReader in) throws IOException {
<span class="fc bfc" id="L582" title="All 2 branches covered.">          if (in.peek() == JsonToken.NULL) {</span>
<span class="fc" id="L583">            in.nextNull();</span>
<span class="fc" id="L584">            return null;</span>
          }
<span class="fc" id="L586">          String nextString = in.nextString();</span>
<span class="pc bpc" id="L587" title="1 of 2 branches missed.">          return nextString.equals(&quot;null&quot;) ? null : new URL(nextString);</span>
        }

        @Override
        public void write(JsonWriter out, URL value) throws IOException {
<span class="fc bfc" id="L592" title="All 2 branches covered.">          out.value(value == null ? null : value.toExternalForm());</span>
<span class="fc" id="L593">        }</span>
      };

<span class="fc" id="L596">  public static final TypeAdapterFactory URL_FACTORY = newFactory(URL.class, URL);</span>

<span class="fc" id="L598">  public static final TypeAdapter&lt;URI&gt; URI =</span>
<span class="fc" id="L599">      new TypeAdapter&lt;URI&gt;() {</span>
        @Override
        public URI read(JsonReader in) throws IOException {
<span class="fc bfc" id="L602" title="All 2 branches covered.">          if (in.peek() == JsonToken.NULL) {</span>
<span class="fc" id="L603">            in.nextNull();</span>
<span class="fc" id="L604">            return null;</span>
          }
          try {
<span class="fc" id="L607">            String nextString = in.nextString();</span>
<span class="pc bpc" id="L608" title="1 of 2 branches missed.">            return nextString.equals(&quot;null&quot;) ? null : new URI(nextString);</span>
<span class="nc" id="L609">          } catch (URISyntaxException e) {</span>
<span class="nc" id="L610">            throw new JsonIOException(e);</span>
          }
        }

        @Override
        public void write(JsonWriter out, URI value) throws IOException {
<span class="fc bfc" id="L616" title="All 2 branches covered.">          out.value(value == null ? null : value.toASCIIString());</span>
<span class="fc" id="L617">        }</span>
      };

<span class="fc" id="L620">  public static final TypeAdapterFactory URI_FACTORY = newFactory(URI.class, URI);</span>

<span class="fc" id="L622">  public static final TypeAdapter&lt;InetAddress&gt; INET_ADDRESS =</span>
<span class="fc" id="L623">      new TypeAdapter&lt;InetAddress&gt;() {</span>
        @Override
        public InetAddress read(JsonReader in) throws IOException {
<span class="pc bpc" id="L626" title="1 of 2 branches missed.">          if (in.peek() == JsonToken.NULL) {</span>
<span class="fc" id="L627">            in.nextNull();</span>
<span class="fc" id="L628">            return null;</span>
          }
          // regrettably, this should have included both the host name and the host address
          // For compatibility, we use InetAddress.getByName rather than the possibly-better
          // .getAllByName
          @SuppressWarnings(&quot;AddressSelection&quot;)
<span class="nc" id="L634">          InetAddress addr = InetAddress.getByName(in.nextString());</span>
<span class="nc" id="L635">          return addr;</span>
        }

        @Override
        public void write(JsonWriter out, InetAddress value) throws IOException {
<span class="pc bpc" id="L640" title="1 of 2 branches missed.">          out.value(value == null ? null : value.getHostAddress());</span>
<span class="fc" id="L641">        }</span>
      };

<span class="fc" id="L644">  public static final TypeAdapterFactory INET_ADDRESS_FACTORY =</span>
<span class="fc" id="L645">      newTypeHierarchyFactory(InetAddress.class, INET_ADDRESS);</span>

<span class="fc" id="L647">  public static final TypeAdapter&lt;UUID&gt; UUID =</span>
<span class="fc" id="L648">      new TypeAdapter&lt;UUID&gt;() {</span>
        @Override
        public UUID read(JsonReader in) throws IOException {
<span class="fc bfc" id="L651" title="All 2 branches covered.">          if (in.peek() == JsonToken.NULL) {</span>
<span class="fc" id="L652">            in.nextNull();</span>
<span class="fc" id="L653">            return null;</span>
          }
<span class="fc" id="L655">          String s = in.nextString();</span>
          try {
<span class="fc" id="L657">            return java.util.UUID.fromString(s);</span>
<span class="nc" id="L658">          } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L659">            throw new JsonSyntaxException(</span>
<span class="nc" id="L660">                &quot;Failed parsing '&quot; + s + &quot;' as UUID; at path &quot; + in.getPreviousPath(), e);</span>
          }
        }

        @Override
        public void write(JsonWriter out, UUID value) throws IOException {
<span class="fc bfc" id="L666" title="All 2 branches covered.">          out.value(value == null ? null : value.toString());</span>
<span class="fc" id="L667">        }</span>
      };

<span class="fc" id="L670">  public static final TypeAdapterFactory UUID_FACTORY = newFactory(UUID.class, UUID);</span>

<span class="fc" id="L672">  public static final TypeAdapter&lt;Currency&gt; CURRENCY =</span>
<span class="fc" id="L673">      new TypeAdapter&lt;Currency&gt;() {</span>
        @Override
        public Currency read(JsonReader in) throws IOException {
<span class="fc" id="L676">          String s = in.nextString();</span>
          try {
<span class="fc" id="L678">            return Currency.getInstance(s);</span>
<span class="nc" id="L679">          } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L680">            throw new JsonSyntaxException(</span>
<span class="nc" id="L681">                &quot;Failed parsing '&quot; + s + &quot;' as Currency; at path &quot; + in.getPreviousPath(), e);</span>
          }
        }

        @Override
        public void write(JsonWriter out, Currency value) throws IOException {
<span class="fc" id="L687">          out.value(value.getCurrencyCode());</span>
<span class="fc" id="L688">        }</span>
<span class="fc" id="L689">      }.nullSafe();</span>
<span class="fc" id="L690">  public static final TypeAdapterFactory CURRENCY_FACTORY = newFactory(Currency.class, CURRENCY);</span>

<span class="fc" id="L692">  public static final TypeAdapter&lt;Calendar&gt; CALENDAR =</span>
<span class="fc" id="L693">      new TypeAdapter&lt;Calendar&gt;() {</span>
        private static final String YEAR = &quot;year&quot;;
        private static final String MONTH = &quot;month&quot;;
        private static final String DAY_OF_MONTH = &quot;dayOfMonth&quot;;
        private static final String HOUR_OF_DAY = &quot;hourOfDay&quot;;
        private static final String MINUTE = &quot;minute&quot;;
        private static final String SECOND = &quot;second&quot;;

        @Override
        public Calendar read(JsonReader in) throws IOException {
<span class="fc bfc" id="L703" title="All 2 branches covered.">          if (in.peek() == JsonToken.NULL) {</span>
<span class="fc" id="L704">            in.nextNull();</span>
<span class="fc" id="L705">            return null;</span>
          }
<span class="fc" id="L707">          in.beginObject();</span>
<span class="fc" id="L708">          int year = 0;</span>
<span class="fc" id="L709">          int month = 0;</span>
<span class="fc" id="L710">          int dayOfMonth = 0;</span>
<span class="fc" id="L711">          int hourOfDay = 0;</span>
<span class="fc" id="L712">          int minute = 0;</span>
<span class="fc" id="L713">          int second = 0;</span>
<span class="fc bfc" id="L714" title="All 2 branches covered.">          while (in.peek() != JsonToken.END_OBJECT) {</span>
<span class="fc" id="L715">            String name = in.nextName();</span>
<span class="fc" id="L716">            int value = in.nextInt();</span>
<span class="pc bpc" id="L717" title="1 of 7 branches missed.">            switch (name) {</span>
              case YEAR:
<span class="fc" id="L719">                year = value;</span>
<span class="fc" id="L720">                break;</span>
              case MONTH:
<span class="fc" id="L722">                month = value;</span>
<span class="fc" id="L723">                break;</span>
              case DAY_OF_MONTH:
<span class="fc" id="L725">                dayOfMonth = value;</span>
<span class="fc" id="L726">                break;</span>
              case HOUR_OF_DAY:
<span class="fc" id="L728">                hourOfDay = value;</span>
<span class="fc" id="L729">                break;</span>
              case MINUTE:
<span class="fc" id="L731">                minute = value;</span>
<span class="fc" id="L732">                break;</span>
              case SECOND:
<span class="fc" id="L734">                second = value;</span>
<span class="fc" id="L735">                break;</span>
              default:
                // Ignore unknown JSON property
            }
<span class="fc" id="L739">          }</span>
<span class="fc" id="L740">          in.endObject();</span>
<span class="fc" id="L741">          return new GregorianCalendar(year, month, dayOfMonth, hourOfDay, minute, second);</span>
        }

        @Override
        public void write(JsonWriter out, Calendar value) throws IOException {
<span class="fc bfc" id="L746" title="All 2 branches covered.">          if (value == null) {</span>
<span class="fc" id="L747">            out.nullValue();</span>
<span class="fc" id="L748">            return;</span>
          }
<span class="fc" id="L750">          out.beginObject();</span>
<span class="fc" id="L751">          out.name(YEAR);</span>
<span class="fc" id="L752">          out.value(value.get(Calendar.YEAR));</span>
<span class="fc" id="L753">          out.name(MONTH);</span>
<span class="fc" id="L754">          out.value(value.get(Calendar.MONTH));</span>
<span class="fc" id="L755">          out.name(DAY_OF_MONTH);</span>
<span class="fc" id="L756">          out.value(value.get(Calendar.DAY_OF_MONTH));</span>
<span class="fc" id="L757">          out.name(HOUR_OF_DAY);</span>
<span class="fc" id="L758">          out.value(value.get(Calendar.HOUR_OF_DAY));</span>
<span class="fc" id="L759">          out.name(MINUTE);</span>
<span class="fc" id="L760">          out.value(value.get(Calendar.MINUTE));</span>
<span class="fc" id="L761">          out.name(SECOND);</span>
<span class="fc" id="L762">          out.value(value.get(Calendar.SECOND));</span>
<span class="fc" id="L763">          out.endObject();</span>
<span class="fc" id="L764">        }</span>
      };

<span class="fc" id="L767">  public static final TypeAdapterFactory CALENDAR_FACTORY =</span>
<span class="fc" id="L768">      newFactoryForMultipleTypes(Calendar.class, GregorianCalendar.class, CALENDAR);</span>

<span class="fc" id="L770">  public static final TypeAdapter&lt;Locale&gt; LOCALE =</span>
<span class="fc" id="L771">      new TypeAdapter&lt;Locale&gt;() {</span>
        @Override
        public Locale read(JsonReader in) throws IOException {
<span class="fc bfc" id="L774" title="All 2 branches covered.">          if (in.peek() == JsonToken.NULL) {</span>
<span class="fc" id="L775">            in.nextNull();</span>
<span class="fc" id="L776">            return null;</span>
          }
<span class="fc" id="L778">          String locale = in.nextString();</span>
<span class="fc" id="L779">          StringTokenizer tokenizer = new StringTokenizer(locale, &quot;_&quot;);</span>
<span class="fc" id="L780">          String language = null;</span>
<span class="fc" id="L781">          String country = null;</span>
<span class="fc" id="L782">          String variant = null;</span>
<span class="pc bpc" id="L783" title="1 of 2 branches missed.">          if (tokenizer.hasMoreElements()) {</span>
<span class="fc" id="L784">            language = tokenizer.nextToken();</span>
          }
<span class="fc bfc" id="L786" title="All 2 branches covered.">          if (tokenizer.hasMoreElements()) {</span>
<span class="fc" id="L787">            country = tokenizer.nextToken();</span>
          }
<span class="fc bfc" id="L789" title="All 2 branches covered.">          if (tokenizer.hasMoreElements()) {</span>
<span class="fc" id="L790">            variant = tokenizer.nextToken();</span>
          }
<span class="pc bpc" id="L792" title="1 of 4 branches missed.">          if (country == null &amp;&amp; variant == null) {</span>
<span class="fc" id="L793">            return new Locale(language);</span>
<span class="fc bfc" id="L794" title="All 2 branches covered.">          } else if (variant == null) {</span>
<span class="fc" id="L795">            return new Locale(language, country);</span>
          } else {
<span class="fc" id="L797">            return new Locale(language, country, variant);</span>
          }
        }

        @Override
        public void write(JsonWriter out, Locale value) throws IOException {
<span class="fc bfc" id="L803" title="All 2 branches covered.">          out.value(value == null ? null : value.toString());</span>
<span class="fc" id="L804">        }</span>
      };

<span class="fc" id="L807">  public static final TypeAdapterFactory LOCALE_FACTORY = newFactory(Locale.class, LOCALE);</span>

<span class="fc" id="L809">  public static final TypeAdapter&lt;JsonElement&gt; JSON_ELEMENT = JsonElementTypeAdapter.ADAPTER;</span>

<span class="fc" id="L811">  public static final TypeAdapterFactory JSON_ELEMENT_FACTORY =</span>
<span class="fc" id="L812">      newTypeHierarchyFactory(JsonElement.class, JSON_ELEMENT);</span>

<span class="fc" id="L814">  public static final TypeAdapterFactory ENUM_FACTORY = EnumTypeAdapter.FACTORY;</span>

  @SuppressWarnings(&quot;TypeParameterNaming&quot;)
  public static &lt;TT&gt; TypeAdapterFactory newFactory(
      TypeToken&lt;TT&gt; type, TypeAdapter&lt;TT&gt; typeAdapter) {
<span class="fc" id="L819">    return new TypeAdapterFactory() {</span>
      @SuppressWarnings(&quot;unchecked&quot;) // we use a runtime check to make sure the 'T's equal
      @Override
      public &lt;T&gt; TypeAdapter&lt;T&gt; create(Gson gson, TypeToken&lt;T&gt; typeToken) {
<span class="fc bfc" id="L823" title="All 2 branches covered.">        return typeToken.equals(type) ? (TypeAdapter&lt;T&gt;) typeAdapter : null;</span>
      }
    };
  }

  @SuppressWarnings(&quot;TypeParameterNaming&quot;)
  public static &lt;TT&gt; TypeAdapterFactory newFactory(Class&lt;TT&gt; type, TypeAdapter&lt;TT&gt; typeAdapter) {
<span class="fc" id="L830">    return new TypeAdapterFactory() {</span>
      @SuppressWarnings(&quot;unchecked&quot;) // we use a runtime check to make sure the 'T's equal
      @Override
      public &lt;T&gt; TypeAdapter&lt;T&gt; create(Gson gson, TypeToken&lt;T&gt; typeToken) {
<span class="fc bfc" id="L834" title="All 2 branches covered.">        return typeToken.getRawType() == type ? (TypeAdapter&lt;T&gt;) typeAdapter : null;</span>
      }

      @Override
      public String toString() {
<span class="nc" id="L839">        return &quot;Factory[type=&quot; + type.getName() + &quot;,adapter=&quot; + typeAdapter + &quot;]&quot;;</span>
      }
    };
  }

  @SuppressWarnings(&quot;TypeParameterNaming&quot;)
  public static &lt;TT&gt; TypeAdapterFactory newFactory(
      Class&lt;TT&gt; unboxed, Class&lt;TT&gt; boxed, TypeAdapter&lt;? super TT&gt; typeAdapter) {
<span class="fc" id="L847">    return new TypeAdapterFactory() {</span>
      @SuppressWarnings(&quot;unchecked&quot;) // we use a runtime check to make sure the 'T's equal
      @Override
      public &lt;T&gt; TypeAdapter&lt;T&gt; create(Gson gson, TypeToken&lt;T&gt; typeToken) {
<span class="fc" id="L851">        Class&lt;? super T&gt; rawType = typeToken.getRawType();</span>
<span class="fc bfc" id="L852" title="All 4 branches covered.">        return (rawType == unboxed || rawType == boxed) ? (TypeAdapter&lt;T&gt;) typeAdapter : null;</span>
      }

      @Override
      public String toString() {
<span class="nc" id="L857">        return &quot;Factory[type=&quot;</span>
<span class="nc" id="L858">            + boxed.getName()</span>
            + &quot;+&quot;
<span class="nc" id="L860">            + unboxed.getName()</span>
            + &quot;,adapter=&quot;
            + typeAdapter
            + &quot;]&quot;;
      }
    };
  }

  @SuppressWarnings(&quot;TypeParameterNaming&quot;)
  public static &lt;TT&gt; TypeAdapterFactory newFactoryForMultipleTypes(
      Class&lt;TT&gt; base, Class&lt;? extends TT&gt; sub, TypeAdapter&lt;? super TT&gt; typeAdapter) {
<span class="fc" id="L871">    return new TypeAdapterFactory() {</span>
      @SuppressWarnings(&quot;unchecked&quot;) // we use a runtime check to make sure the 'T's equal
      @Override
      public &lt;T&gt; TypeAdapter&lt;T&gt; create(Gson gson, TypeToken&lt;T&gt; typeToken) {
<span class="fc" id="L875">        Class&lt;? super T&gt; rawType = typeToken.getRawType();</span>
<span class="fc bfc" id="L876" title="All 4 branches covered.">        return (rawType == base || rawType == sub) ? (TypeAdapter&lt;T&gt;) typeAdapter : null;</span>
      }

      @Override
      public String toString() {
<span class="nc" id="L881">        return &quot;Factory[type=&quot;</span>
<span class="nc" id="L882">            + base.getName()</span>
            + &quot;+&quot;
<span class="nc" id="L884">            + sub.getName()</span>
            + &quot;,adapter=&quot;
            + typeAdapter
            + &quot;]&quot;;
      }
    };
  }

  /**
   * Returns a factory for all subtypes of {@code typeAdapter}. We do a runtime check to confirm
   * that the deserialized type matches the type requested.
   */
  public static &lt;T1&gt; TypeAdapterFactory newTypeHierarchyFactory(
      Class&lt;T1&gt; clazz, TypeAdapter&lt;T1&gt; typeAdapter) {
<span class="fc" id="L898">    return new TypeAdapterFactory() {</span>
      @SuppressWarnings(&quot;unchecked&quot;)
      @Override
      public &lt;T2&gt; TypeAdapter&lt;T2&gt; create(Gson gson, TypeToken&lt;T2&gt; typeToken) {
<span class="fc" id="L902">        Class&lt;? super T2&gt; requestedType = typeToken.getRawType();</span>
<span class="fc bfc" id="L903" title="All 2 branches covered.">        if (!clazz.isAssignableFrom(requestedType)) {</span>
<span class="fc" id="L904">          return null;</span>
        }
<span class="fc" id="L906">        return (TypeAdapter&lt;T2&gt;)</span>
<span class="fc" id="L907">            new TypeAdapter&lt;T1&gt;() {</span>
              @Override
              public void write(JsonWriter out, T1 value) throws IOException {
<span class="fc" id="L910">                typeAdapter.write(out, value);</span>
<span class="fc" id="L911">              }</span>

              @Override
              public T1 read(JsonReader in) throws IOException {
<span class="fc" id="L915">                T1 result = typeAdapter.read(in);</span>
<span class="fc bfc" id="L916" title="All 4 branches covered.">                if (result != null &amp;&amp; !requestedType.isInstance(result)) {</span>
<span class="fc" id="L917">                  throw new JsonSyntaxException(</span>
                      &quot;Expected a &quot;
<span class="fc" id="L919">                          + requestedType.getName()</span>
                          + &quot; but was &quot;
<span class="fc" id="L921">                          + result.getClass().getName()</span>
                          + &quot;; at path &quot;
<span class="fc" id="L923">                          + in.getPreviousPath());</span>
                }
<span class="fc" id="L925">                return result;</span>
              }
            };
      }

      @Override
      public String toString() {
<span class="nc" id="L932">        return &quot;Factory[typeHierarchy=&quot; + clazz.getName() + &quot;,adapter=&quot; + typeAdapter + &quot;]&quot;;</span>
      }
    };
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>